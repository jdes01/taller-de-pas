{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Inicio \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias . Contenido \u00b6 Inicio Sesi\u00f3n 1 Sesi\u00f3n 2 Referencias Agradecimientos \u00b6 Este curso ha sido impartido por las siguientes personas: Alberto Cano Antonio Moruno David P\u00e9rez David Salcedo Javier de Santiago Moises Moyano Marcos Rivera Marcos Rodr\u00edguez Licencia \u00b6 El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Inicio"},{"location":"#inicio","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias .","title":"Inicio"},{"location":"#contenido","text":"Inicio Sesi\u00f3n 1 Sesi\u00f3n 2 Referencias","title":"Contenido"},{"location":"#agradecimientos","text":"Este curso ha sido impartido por las siguientes personas: Alberto Cano Antonio Moruno David P\u00e9rez David Salcedo Javier de Santiago Moises Moyano Marcos Rivera Marcos Rodr\u00edguez","title":"Agradecimientos"},{"location":"#licencia","text":"El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Licencia"},{"location":"referencias/","text":"Referencias \u00b6 Documentaci\u00f3n oficial en ingl\u00e9s .","title":"Referencias"},{"location":"referencias/#referencias","text":"Documentaci\u00f3n oficial en ingl\u00e9s .","title":"Referencias"},{"location":"Sesion-1/Apache/","text":"Creaci\u00f3n de una aplicacion React \u00b6 Creaci\u00f3n de una imagen Apache \u00b6 Para la creaci\u00f3n de este servidor utilizaremos la imagen httpd , en la que haremos deploy de un servidor Apache, para m\u00e1s adelante en el workshop, hagamos deployment de un frontend en React a trav\u00e9s de esta imagen. [ ! ] El repositorio desde el que empezamos es: https://github.com/mark-doblefilo/pas-workshop o tambi\u00e9n podemos utilizar: npx create-react-app pas-workshop Creando nuestra imagen con Dockerfile \u00b6 Primero de todo, para generar una imagen a partir de la imagen base httpd, necesitaremos crear nuestra propia imagen. Para ello creamos el archivo Dockerfile: FROM httpd EXPOSE 80 CMD [ \"httpd-foreground\" ] Tras esto, ejecutariamos el siguiente comando en terminal: docker build -t apache-image . Con el siguiente resultado: Sending build context to Docker daemon 191.1MB Step 1/3 : FROM httpd ---> 0b932df43057 Step 2/3 : EXPOSE 80 ---> Using cache ---> 024fc3423791 Step 3/3 : CMD [\"httpd-foreground\"] ---> Using cache ---> dc01a168338b Successfully built dc01a168338b Successfully tagged apache-image:latest Creando nuestro contenedor a partir de la imagen Apache \u00b6 Ya tenemos creada nuestra imagen con nombre apache-image . Lo siguiente ser\u00eda generar el contenedor para iniciar y probar nuestra imagen: docker run -d --name apache-container -p 8080:80 apache-image Comando Podr\u00edamos ver el estado del contenedor ejecutando: docker ps Ahora podemos entrar en la p\u00e1gina web, recordemos que con la flag p hemos asignado el puerto 80 de nuestro apache (puerto por defecto) al puerto 8080 de nuestro localhost. Para probar nuestro contenedor abriremos un navegador e iremos a localhost:8080 Creando nuestro entorno de desarrollo en React \u00b6 Para crear nuestro entorno de desarrollo utilizaremos otra imagen, en este caso utilizaremos node . Node.js es una plataforma basada en Javascript para server-side y networking applications. Adem\u00e1s esta imagen base nos permite algo denominado hot reload tal que cuando modifiquemos alguna cosa en nuestro c\u00f3digo se actualice en nuestro contenedor y podamos verlo al instante. Adem\u00e1s utilizaremos docker-compose que nos permitir\u00e1 facilitarnos la construcci\u00f3n de la imagen y el contenedor. Creando nuestro Dockerfile y docker-compose \u00b6 Como en la anterior caso, empezaremos con la creaci\u00f3n de un Dockerfile, en este caso partiremos de una imagen base diferente pero que nos ayudar\u00e1 en nuestra etapa de desarrollo. FROM node:13.12.0-alpine WORKDIR /app # /app/node_modules/.bin to $PATH ENV PATH /app/node_modules/.bin: $PATH COPY package.json ./ COPY package-lock.json ./ RUN npm install --silent RUN npm install react-scripts@3.4.1 -g --silent COPY . ./ CMD [ \"npm\" , \"start\" ] Crearemos un .dockerignore para hacer que la creaci\u00f3n de nuestra imagen sea mucho m\u00e1s r\u00e1pida: node_modules build .dockerignore Dockerfile Dockerfile.prod Y por \u00faltimo crearemos el docker-compose.yml: version : '3.7' services : react-service : container_name : react-container build : context : . dockerfile : Dockerfile volumes : - '.:/app' - '/app/node_modules' ports : - 8080:3000 environment : - CHOKIDAR_USEPOLLING=true Creando nuestro entorno de producci\u00f3n \u00b6 Seguiremos con los mismos pasos (Dockerfile y docker-compose): Dockerfile.prod # STAGE 1 FROM node:13.12.0-alpine as build WORKDIR /app # /app/node_modules/.bin to $PATH ENV PATH /app/node_modules/.bin: $PATH COPY package.json ./ COPY package-lock.json ./ RUN npm ci --silent RUN npm install react-scripts@3.4.1 -g --silent COPY . ./ RUN npm run build # STAGE 2 FROM httpd COPY --from = build /app/build /usr/local/apache2/htdocs EXPOSE 80 CMD [ \"httpd-foreground\" ] docker-compose.prod.yml version : '3.7' services : react-prod : container_name : react-prod build : context : . dockerfile : Dockerfile.prod ports : - '80:80' Para ejecutar nuestros servicios de producci\u00f3n utilizaremos: docker-compose -f \"docker-compose.prod.yml\" up -d --build Importante El comando docker-compose ps nos mostrar\u00e1 los servicios de un fichero (por defecto: docker-compose.yml). Si nuestro fichero tiene un nombre diferente, entonces lo tendremos que indicar con la flag -f \"example.yml\". Y ya tendremos nuestro React dockerizado y en producci\u00f3n, el puerto indicado es 80 (conexiones http), entonces al abrir un navegador y poner en la URL: localhost:80","title":"Creaci\u00f3n de una aplicacion React"},{"location":"Sesion-1/Apache/#creacion-de-una-aplicacion-react","text":"","title":"Creaci\u00f3n de una aplicacion React"},{"location":"Sesion-1/Apache/#creacion-de-una-imagen-apache","text":"Para la creaci\u00f3n de este servidor utilizaremos la imagen httpd , en la que haremos deploy de un servidor Apache, para m\u00e1s adelante en el workshop, hagamos deployment de un frontend en React a trav\u00e9s de esta imagen. [ ! ] El repositorio desde el que empezamos es: https://github.com/mark-doblefilo/pas-workshop o tambi\u00e9n podemos utilizar: npx create-react-app pas-workshop","title":"Creaci\u00f3n de una imagen Apache"},{"location":"Sesion-1/Apache/#creando-nuestra-imagen-con-dockerfile","text":"Primero de todo, para generar una imagen a partir de la imagen base httpd, necesitaremos crear nuestra propia imagen. Para ello creamos el archivo Dockerfile: FROM httpd EXPOSE 80 CMD [ \"httpd-foreground\" ] Tras esto, ejecutariamos el siguiente comando en terminal: docker build -t apache-image . Con el siguiente resultado: Sending build context to Docker daemon 191.1MB Step 1/3 : FROM httpd ---> 0b932df43057 Step 2/3 : EXPOSE 80 ---> Using cache ---> 024fc3423791 Step 3/3 : CMD [\"httpd-foreground\"] ---> Using cache ---> dc01a168338b Successfully built dc01a168338b Successfully tagged apache-image:latest","title":"Creando nuestra imagen con Dockerfile"},{"location":"Sesion-1/Apache/#creando-nuestro-contenedor-a-partir-de-la-imagen-apache","text":"Ya tenemos creada nuestra imagen con nombre apache-image . Lo siguiente ser\u00eda generar el contenedor para iniciar y probar nuestra imagen: docker run -d --name apache-container -p 8080:80 apache-image Comando Podr\u00edamos ver el estado del contenedor ejecutando: docker ps Ahora podemos entrar en la p\u00e1gina web, recordemos que con la flag p hemos asignado el puerto 80 de nuestro apache (puerto por defecto) al puerto 8080 de nuestro localhost. Para probar nuestro contenedor abriremos un navegador e iremos a localhost:8080","title":"Creando nuestro contenedor a partir de la imagen Apache"},{"location":"Sesion-1/Apache/#creando-nuestro-entorno-de-desarrollo-en-react","text":"Para crear nuestro entorno de desarrollo utilizaremos otra imagen, en este caso utilizaremos node . Node.js es una plataforma basada en Javascript para server-side y networking applications. Adem\u00e1s esta imagen base nos permite algo denominado hot reload tal que cuando modifiquemos alguna cosa en nuestro c\u00f3digo se actualice en nuestro contenedor y podamos verlo al instante. Adem\u00e1s utilizaremos docker-compose que nos permitir\u00e1 facilitarnos la construcci\u00f3n de la imagen y el contenedor.","title":"Creando nuestro entorno de desarrollo en React"},{"location":"Sesion-1/Apache/#creando-nuestro-dockerfile-y-docker-compose","text":"Como en la anterior caso, empezaremos con la creaci\u00f3n de un Dockerfile, en este caso partiremos de una imagen base diferente pero que nos ayudar\u00e1 en nuestra etapa de desarrollo. FROM node:13.12.0-alpine WORKDIR /app # /app/node_modules/.bin to $PATH ENV PATH /app/node_modules/.bin: $PATH COPY package.json ./ COPY package-lock.json ./ RUN npm install --silent RUN npm install react-scripts@3.4.1 -g --silent COPY . ./ CMD [ \"npm\" , \"start\" ] Crearemos un .dockerignore para hacer que la creaci\u00f3n de nuestra imagen sea mucho m\u00e1s r\u00e1pida: node_modules build .dockerignore Dockerfile Dockerfile.prod Y por \u00faltimo crearemos el docker-compose.yml: version : '3.7' services : react-service : container_name : react-container build : context : . dockerfile : Dockerfile volumes : - '.:/app' - '/app/node_modules' ports : - 8080:3000 environment : - CHOKIDAR_USEPOLLING=true","title":"Creando nuestro Dockerfile y docker-compose"},{"location":"Sesion-1/Apache/#creando-nuestro-entorno-de-produccion","text":"Seguiremos con los mismos pasos (Dockerfile y docker-compose): Dockerfile.prod # STAGE 1 FROM node:13.12.0-alpine as build WORKDIR /app # /app/node_modules/.bin to $PATH ENV PATH /app/node_modules/.bin: $PATH COPY package.json ./ COPY package-lock.json ./ RUN npm ci --silent RUN npm install react-scripts@3.4.1 -g --silent COPY . ./ RUN npm run build # STAGE 2 FROM httpd COPY --from = build /app/build /usr/local/apache2/htdocs EXPOSE 80 CMD [ \"httpd-foreground\" ] docker-compose.prod.yml version : '3.7' services : react-prod : container_name : react-prod build : context : . dockerfile : Dockerfile.prod ports : - '80:80' Para ejecutar nuestros servicios de producci\u00f3n utilizaremos: docker-compose -f \"docker-compose.prod.yml\" up -d --build Importante El comando docker-compose ps nos mostrar\u00e1 los servicios de un fichero (por defecto: docker-compose.yml). Si nuestro fichero tiene un nombre diferente, entonces lo tendremos que indicar con la flag -f \"example.yml\". Y ya tendremos nuestro React dockerizado y en producci\u00f3n, el puerto indicado es 80 (conexiones http), entonces al abrir un navegador y poner en la URL: localhost:80","title":"Creando nuestro entorno de producci\u00f3n"},{"location":"Sesion-1/Contenedores/","text":"Contenedores \u00b6 Los contenedores son instancias de las im\u00e1genes que hemos creado o hemos descargado y que se ejecutan de forma aislada. Listado \u00b6 Para ver el listado de contenedores, usaremos: - docker container ls o - docker ps (versi\u00f3n abreviada) Si lo ejecutamos, nos dar\u00e1 un listado vac\u00edo porque no hay ning\u00fan contenedor activo. para ver el listado de contenedores parados, usaremos: - docker container ls -a o - docker ps -a (versi\u00f3n abreviada) Ejecutar comandos dentro de una contenedor \u00b6 Ya hemos usado el comando docker run para crear e iniciar nuestro contenedro, pero tambi\u00e9n podemos usar este comando para ejecutar programas que est\u00e9n dentro del contenedor: docker run --name ubuntu_bash --rm -i -t ubuntu bash Pero esra forma de ejecutar las cosas, crea un nuevo contenedor. Si queremos ejecutar un comando en un contenedor que ya est\u00e9 iniciado, usaremos: docker container exec Sin cerrar este terminal, ejecutamos en otra terminal: docker exec -w /tmp ubuntu_bash touch my_file.sh Donde: -w -> indica el directorio de trabajo ubuntu_bash -> indicamos el contenedor donde queremos ejecutar el comando touch my_file.sh -> el comando a ejecutar Para cerrar y borrar el contenedor, usamos: Control+c Iniciar un contenedor \u00b6 Para inciar un contenedor parado, usaremos: docker container start Detener un contenedor \u00b6 Para detener un contenedor iniciado, usaremos: docker container stop (id / nombre) Indicando su id o su nombre Borrar un contenedor \u00b6 Un contenedor parada ocupa espacio. Si hemos dejado de necesitar uin contenedor, podemos usar el siguiente comando para borrarlo: docker container rm (id / nombre) Indicando al igual que con la opci\u00f3n de detener, su id o nombre.","title":"Contenedores"},{"location":"Sesion-1/Contenedores/#contenedores","text":"Los contenedores son instancias de las im\u00e1genes que hemos creado o hemos descargado y que se ejecutan de forma aislada.","title":"Contenedores"},{"location":"Sesion-1/Contenedores/#listado","text":"Para ver el listado de contenedores, usaremos: - docker container ls o - docker ps (versi\u00f3n abreviada) Si lo ejecutamos, nos dar\u00e1 un listado vac\u00edo porque no hay ning\u00fan contenedor activo. para ver el listado de contenedores parados, usaremos: - docker container ls -a o - docker ps -a (versi\u00f3n abreviada)","title":"Listado"},{"location":"Sesion-1/Contenedores/#ejecutar-comandos-dentro-de-una-contenedor","text":"Ya hemos usado el comando docker run para crear e iniciar nuestro contenedro, pero tambi\u00e9n podemos usar este comando para ejecutar programas que est\u00e9n dentro del contenedor: docker run --name ubuntu_bash --rm -i -t ubuntu bash Pero esra forma de ejecutar las cosas, crea un nuevo contenedor. Si queremos ejecutar un comando en un contenedor que ya est\u00e9 iniciado, usaremos: docker container exec Sin cerrar este terminal, ejecutamos en otra terminal: docker exec -w /tmp ubuntu_bash touch my_file.sh Donde: -w -> indica el directorio de trabajo ubuntu_bash -> indicamos el contenedor donde queremos ejecutar el comando touch my_file.sh -> el comando a ejecutar Para cerrar y borrar el contenedor, usamos: Control+c","title":"Ejecutar comandos dentro de una contenedor"},{"location":"Sesion-1/Contenedores/#iniciar-un-contenedor","text":"Para inciar un contenedor parado, usaremos: docker container start","title":"Iniciar un contenedor"},{"location":"Sesion-1/Contenedores/#detener-un-contenedor","text":"Para detener un contenedor iniciado, usaremos: docker container stop (id / nombre) Indicando su id o su nombre","title":"Detener un contenedor"},{"location":"Sesion-1/Contenedores/#borrar-un-contenedor","text":"Un contenedor parada ocupa espacio. Si hemos dejado de necesitar uin contenedor, podemos usar el siguiente comando para borrarlo: docker container rm (id / nombre) Indicando al igual que con la opci\u00f3n de detener, su id o nombre.","title":"Borrar un contenedor"},{"location":"Sesion-1/Im%C3%A1genes/","text":"Im\u00e1genes \u00b6 Son la bade de Docker ya que nuestros contenedores se iniciar\u00e1n a partir de ellas. Como ya se indic\u00f3 en la introducci\u00f3n, es una plantilla de solo lectura, que se crea incorporando los requisitos necesarios para cumplir el objetivo para el cual fue creada. Buscar im\u00e1genes \u00b6 Crear una imagen desde cero supone un esfuerzo grand\u00edsimo, as\u00ed que lo normal es partir o usar una ya creada. Para ello buscaremos en los registros que son el lugar donde se almacenan. Hay un registro oficial https://hub.docker.com , pero nada impide a otras organizaciones, o incluso a nosotros mismo, tener un registro propio. Estos pueden ser tanto p\u00fablicos como privados. Vamos a imaginarnos que queremos crear una web con Wordpress . Si buscamos en el registro, encontraremos una imagen llamada wordpress , con la etiqueta oficial. La recomendaci\u00f3n es que siempre busquemos im\u00e1genes oficiales, ya que est\u00e1n mantenidas y bien documentadas. Gesti\u00f3n de im\u00e1genes \u00b6 Descarga \u00b6 Las imagenes que nos descargamos, se identifican tanto por nombre como por versi\u00f3n. De esa manera, podemos tener distintas versiones de una misma imagen. En la p\u00e1gina del registro veremos una pesta\u00f1a con el nombre Tags , con las versiones disponibles. Para usar una en concreto, se usa dos puntos seguido del nombre de la versi\u00f3n. SI no se indica nada, como hasta ahora, por defecto se descarga la etiquetata como latest Para descargar im\u00e1genes, usaremos: docker pull Listado \u00b6 Para ver el listado de imagenes disponibles, usaremos: docker images Borrado \u00b6 Si queremos dejar de usar alguna imagen, usaremos: docker rmi","title":"Im\u00e1genes"},{"location":"Sesion-1/Im%C3%A1genes/#imagenes","text":"Son la bade de Docker ya que nuestros contenedores se iniciar\u00e1n a partir de ellas. Como ya se indic\u00f3 en la introducci\u00f3n, es una plantilla de solo lectura, que se crea incorporando los requisitos necesarios para cumplir el objetivo para el cual fue creada.","title":"Im\u00e1genes"},{"location":"Sesion-1/Im%C3%A1genes/#buscar-imagenes","text":"Crear una imagen desde cero supone un esfuerzo grand\u00edsimo, as\u00ed que lo normal es partir o usar una ya creada. Para ello buscaremos en los registros que son el lugar donde se almacenan. Hay un registro oficial https://hub.docker.com , pero nada impide a otras organizaciones, o incluso a nosotros mismo, tener un registro propio. Estos pueden ser tanto p\u00fablicos como privados. Vamos a imaginarnos que queremos crear una web con Wordpress . Si buscamos en el registro, encontraremos una imagen llamada wordpress , con la etiqueta oficial. La recomendaci\u00f3n es que siempre busquemos im\u00e1genes oficiales, ya que est\u00e1n mantenidas y bien documentadas.","title":"Buscar im\u00e1genes"},{"location":"Sesion-1/Im%C3%A1genes/#gestion-de-imagenes","text":"","title":"Gesti\u00f3n de im\u00e1genes"},{"location":"Sesion-1/Im%C3%A1genes/#descarga","text":"Las imagenes que nos descargamos, se identifican tanto por nombre como por versi\u00f3n. De esa manera, podemos tener distintas versiones de una misma imagen. En la p\u00e1gina del registro veremos una pesta\u00f1a con el nombre Tags , con las versiones disponibles. Para usar una en concreto, se usa dos puntos seguido del nombre de la versi\u00f3n. SI no se indica nada, como hasta ahora, por defecto se descarga la etiquetata como latest Para descargar im\u00e1genes, usaremos: docker pull","title":"Descarga"},{"location":"Sesion-1/Im%C3%A1genes/#listado","text":"Para ver el listado de imagenes disponibles, usaremos: docker images","title":"Listado"},{"location":"Sesion-1/Im%C3%A1genes/#borrado","text":"Si queremos dejar de usar alguna imagen, usaremos: docker rmi","title":"Borrado"},{"location":"Sesion-1/Instalaci%C3%B3n/","text":"Instalaci\u00f3n \u00b6 Existen dos versiones de Dcoker, una libre y otra que no lo es. Nos ouparemos exclusivamente de la primera: Docker CE (Community Edition) Disponibilidad \u00b6 Docker CE est\u00e1 disponible para los siguientes sistemas GNU/Linux: CentOS, Debian, Fedora , Raspbian y Ubuntu. Y esta soportado por aruitecturas como x86_64 / amd64 , ARM y ARM64 / AARCH64. Instalaci\u00f3n \u00b6 Debido a que, dependiendo de la distribuci\u00f3n, la forma de instalarlo difiere, es mejor consultar la documentaci\u00f3n oficial para saber como instalar Docker en tu m\u00e1quina. Ubuntu: https://docs.docker.com/engine/install/ubuntu/ Debian: https://docs.docker.com/engine/install/debian/ CentOS: https://docs.docker.com/engine/install/centos/ Fedora: https://docs.docker.com/engine/install/fedora/ Para saber si tienes Docker bien instalado, los tutoriales oficiales siempre te indican que inicies un contenedor de ejemplo. Esto es lo que sucede: $ sudo docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world d1725b59e92d: Pull complete Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ ``` En la l\u00ednea 1 estamos ejecutando el cliente de Docker, y estamos indicando que queremos ejecutar un contenedor a partir de la imagen hello-world del registro p\u00fablico de Docker. Si es la primera vez que hemos ejecutado esa imagen, nos aparecer\u00e1 la l\u00ednea 2, que indica que la imagen no puede ser encontrada y va a proceder a buscarla, por defecto, en el registro p\u00fablico. Si tenemos conexi\u00f3n a Internet se descargar\u00e1 la imagen (l\u00ednea 6) y autom\u00e1ticamente crear\u00e1 un contenedor. Tanto si se ha descargado la imagen o ya estaba descargada, el contenedor se ejecutar\u00e1, obteniendo el texto de bienvenida que se ve en el cuadro anterior. Configuraci\u00f3n del usuario \u00b6 Si estamos usando Docker en nuestro ordenador, podemos configurar nuestro usuario para usar el cliente sin tener que poner sudo delante. Para ello, debemos de ejecutar el siguiente comando: sudo usermod -aG docker $USER Para que surjan efecto los cambios, debemos de cerrar y volver a abrir la sesi\u00f3n. Herramientas \u00b6 Tambi\u00e9n es necesario tener una herramienta llamada Docker Compose. Puedes instalarla siguiendo las instrucciones que se encuentra en la p\u00e1gina de Instalaci\u00f3n de Docker Compose . Sin embargo, si usas Ubuntu o Debian, podemos instalarlo con el siguiente comando: sudo apt install docker-compose","title":"Instalaci\u00f3n"},{"location":"Sesion-1/Instalaci%C3%B3n/#instalacion","text":"Existen dos versiones de Dcoker, una libre y otra que no lo es. Nos ouparemos exclusivamente de la primera: Docker CE (Community Edition)","title":"Instalaci\u00f3n"},{"location":"Sesion-1/Instalaci%C3%B3n/#disponibilidad","text":"Docker CE est\u00e1 disponible para los siguientes sistemas GNU/Linux: CentOS, Debian, Fedora , Raspbian y Ubuntu. Y esta soportado por aruitecturas como x86_64 / amd64 , ARM y ARM64 / AARCH64.","title":"Disponibilidad"},{"location":"Sesion-1/Instalaci%C3%B3n/#instalacion_1","text":"Debido a que, dependiendo de la distribuci\u00f3n, la forma de instalarlo difiere, es mejor consultar la documentaci\u00f3n oficial para saber como instalar Docker en tu m\u00e1quina. Ubuntu: https://docs.docker.com/engine/install/ubuntu/ Debian: https://docs.docker.com/engine/install/debian/ CentOS: https://docs.docker.com/engine/install/centos/ Fedora: https://docs.docker.com/engine/install/fedora/ Para saber si tienes Docker bien instalado, los tutoriales oficiales siempre te indican que inicies un contenedor de ejemplo. Esto es lo que sucede: $ sudo docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world d1725b59e92d: Pull complete Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ ``` En la l\u00ednea 1 estamos ejecutando el cliente de Docker, y estamos indicando que queremos ejecutar un contenedor a partir de la imagen hello-world del registro p\u00fablico de Docker. Si es la primera vez que hemos ejecutado esa imagen, nos aparecer\u00e1 la l\u00ednea 2, que indica que la imagen no puede ser encontrada y va a proceder a buscarla, por defecto, en el registro p\u00fablico. Si tenemos conexi\u00f3n a Internet se descargar\u00e1 la imagen (l\u00ednea 6) y autom\u00e1ticamente crear\u00e1 un contenedor. Tanto si se ha descargado la imagen o ya estaba descargada, el contenedor se ejecutar\u00e1, obteniendo el texto de bienvenida que se ve en el cuadro anterior.","title":"Instalaci\u00f3n"},{"location":"Sesion-1/Instalaci%C3%B3n/#configuracion-del-usuario","text":"Si estamos usando Docker en nuestro ordenador, podemos configurar nuestro usuario para usar el cliente sin tener que poner sudo delante. Para ello, debemos de ejecutar el siguiente comando: sudo usermod -aG docker $USER Para que surjan efecto los cambios, debemos de cerrar y volver a abrir la sesi\u00f3n.","title":"Configuraci\u00f3n del usuario"},{"location":"Sesion-1/Instalaci%C3%B3n/#herramientas","text":"Tambi\u00e9n es necesario tener una herramienta llamada Docker Compose. Puedes instalarla siguiendo las instrucciones que se encuentra en la p\u00e1gina de Instalaci\u00f3n de Docker Compose . Sin embargo, si usas Ubuntu o Debian, podemos instalarlo con el siguiente comando: sudo apt install docker-compose","title":"Herramientas"},{"location":"Sesion-1/Introducci%C3%B3n/","text":"\u00bfQu\u00e9 es Docker? \u00b6 Seg\u00fan Wikipedia: \u00b6 Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales. Seg\u00fan \u201cScalable and resilient Django with Kubernetes\u201d: \u00b6 You can colloquially think of Docker containers as fat static binaries of your apps. They bundle your application code, the underlying libraries and all the necessary bits your app needs to run into a convenient package \u2014 one that can be run on a thin layer directly over the Linux kernel. What this means in practice is that you can take a container that you\u2019ve built once and run it on different versions of Linux distributions, or entirely different Linux distributions. Everything should work seamlessly. \u00bfEst\u00e1 docker virtualizado? \u00b6 En GNU/Linux Docker no es virtualizado, no hay un hipervisor. Los procesos que corren dentro de un contenedor de docker se ejecutan con el mismo kernel que la m\u00e1quina anfitri\u00f3n. Linux lo que hace es aislar esos procesos del resto de procesos del sistema, ya sean los propios de la m\u00e1quina anfitri\u00f3n o procesos de otros contenedores. Adem\u00e1s, es capaz de controlar los recursos que se le asignan a esos contenedores (cpu, memoria, red, etc.). Internamente, el contenedor no sabe que lo es y a todos los efectos es una distribuci\u00f3n GNU/Linux independiente, pero sin la penalizaci\u00f3n de rendimiento que tienen los sistemas virtualizados. As\u00ed que, cuando ejecutamos un contenedor, estamos ejecutando un servicio dentro de una distribuci\u00f3n construida a partir de una \"receta\". Esa receta permite que el sistema que se ejecuta sea siempre el mismo, independientemente de si estamos usando Docker en Ubuntu, Fedora o, incluso, sistemas privativos compatibles con Docker. De esa manera podemos garantizar que estamos desarrollando o desplegando nuestra aplicaci\u00f3n, siempre con la misma versi\u00f3n de todas las dependencias. Obviamente, si ejecutamos contenedores GNU/Linux dentro de sistemas privativos, s\u00ed habr\u00e1 virtualizaci\u00f3n. \u00bfA quien le interesa esto? \u00b6 Docker es \u00fatil a administradores de sistemas, pero tambi\u00e9n a desarrolladores. Uno de los problemas que se presentan durante el desarrollo y despliegue de aplicaciones es encontrarnos con sistemas heterog\u00e9neos, no ya entre los desarrolladores, tambi\u00e9n entre los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n. Es decir, que los desarrolladores y los sistemas donde se ejecuta la aplicaci\u00f3n tienen librer\u00edas y sistemas operativos diferentes. \u00bfY por qu\u00e9 es un problema? Pues porque la aplicaci\u00f3n puede funcionar bien en una distribuci\u00f3n de GNU/Linux pero no bien en otra, o ejecutarse bien con la versi\u00f3n de un lenguaje pero no con otra. Para asegurar la calidad de desarrollo tenemos que asegurar que todo el mundo usa las mismas versiones de todas las aplicaciones y librer\u00edas necesarios. Esto es m\u00e1s complicado de lo que parece, porque hay desarrolladores que prefieron una distribuci\u00f3n concreta, o incluso sistemas privativos. Incluso los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n suelen ser distintos. Los sistemas de producci\u00f3n suelen ser m\u00e1s nuevos y potentes y los antiguos se dejan para pruebas y pre-producci\u00f3n. Otro problema es que un mismo desarrollador o un mismo sistema de despliegue tenga que trabajar en m\u00e1s de un proyecto que requiera versiones distintas de librer\u00edas, complic\u00e1ndolo a\u00fan m\u00e1s. Docker viene a solucionar todos estos problemas, tanto para los desarrolladores como para los administradores de sistemas. Con Docker podemos crear entornos aislados con configuraciones que ser\u00e1n exactamente igual siempre. Conceptos b\u00e1sicos \u00b6 Antes de comenzar a instalar y usar docker es importante tener una serie de conceptos claros: Demonio de docker (docker daemon) : Es el proceso principal de docker. Escucha peticiones a la API y maneja los objetos de docker: im\u00e1genes, contenedores, redes, vol\u00famenes. Tambi\u00e9n es capaz de comunicarse con otros demonios para controlar servicios docker. Cliente de docker (docker client) : Es la principal herramienta que usan los administradores de sistema para interaccionar con el sistema Docker. Registro de docker (docker registry) : Es el lugar donde se almacenan las im\u00e1genes de Docker y poder descargarlas para reutilizarlas. Docker Hub es el principal registro p\u00fablico de Docker y contiene ya un mont\u00f3n de im\u00e1genes listas para ser usadas de multitud de servicios (mysql, wordpress, etc).","title":"\u00bfQu\u00e9 es Docker?"},{"location":"Sesion-1/Introducci%C3%B3n/#que-es-docker","text":"","title":"\u00bfQu\u00e9 es Docker?"},{"location":"Sesion-1/Introducci%C3%B3n/#segun-wikipedia","text":"Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales.","title":"Seg\u00fan Wikipedia:"},{"location":"Sesion-1/Introducci%C3%B3n/#segun-scalable-and-resilient-django-with-kubernetes","text":"You can colloquially think of Docker containers as fat static binaries of your apps. They bundle your application code, the underlying libraries and all the necessary bits your app needs to run into a convenient package \u2014 one that can be run on a thin layer directly over the Linux kernel. What this means in practice is that you can take a container that you\u2019ve built once and run it on different versions of Linux distributions, or entirely different Linux distributions. Everything should work seamlessly.","title":"Seg\u00fan \u201cScalable and resilient Django with Kubernetes\u201d:"},{"location":"Sesion-1/Introducci%C3%B3n/#esta-docker-virtualizado","text":"En GNU/Linux Docker no es virtualizado, no hay un hipervisor. Los procesos que corren dentro de un contenedor de docker se ejecutan con el mismo kernel que la m\u00e1quina anfitri\u00f3n. Linux lo que hace es aislar esos procesos del resto de procesos del sistema, ya sean los propios de la m\u00e1quina anfitri\u00f3n o procesos de otros contenedores. Adem\u00e1s, es capaz de controlar los recursos que se le asignan a esos contenedores (cpu, memoria, red, etc.). Internamente, el contenedor no sabe que lo es y a todos los efectos es una distribuci\u00f3n GNU/Linux independiente, pero sin la penalizaci\u00f3n de rendimiento que tienen los sistemas virtualizados. As\u00ed que, cuando ejecutamos un contenedor, estamos ejecutando un servicio dentro de una distribuci\u00f3n construida a partir de una \"receta\". Esa receta permite que el sistema que se ejecuta sea siempre el mismo, independientemente de si estamos usando Docker en Ubuntu, Fedora o, incluso, sistemas privativos compatibles con Docker. De esa manera podemos garantizar que estamos desarrollando o desplegando nuestra aplicaci\u00f3n, siempre con la misma versi\u00f3n de todas las dependencias. Obviamente, si ejecutamos contenedores GNU/Linux dentro de sistemas privativos, s\u00ed habr\u00e1 virtualizaci\u00f3n.","title":"\u00bfEst\u00e1 docker virtualizado?"},{"location":"Sesion-1/Introducci%C3%B3n/#a-quien-le-interesa-esto","text":"Docker es \u00fatil a administradores de sistemas, pero tambi\u00e9n a desarrolladores. Uno de los problemas que se presentan durante el desarrollo y despliegue de aplicaciones es encontrarnos con sistemas heterog\u00e9neos, no ya entre los desarrolladores, tambi\u00e9n entre los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n. Es decir, que los desarrolladores y los sistemas donde se ejecuta la aplicaci\u00f3n tienen librer\u00edas y sistemas operativos diferentes. \u00bfY por qu\u00e9 es un problema? Pues porque la aplicaci\u00f3n puede funcionar bien en una distribuci\u00f3n de GNU/Linux pero no bien en otra, o ejecutarse bien con la versi\u00f3n de un lenguaje pero no con otra. Para asegurar la calidad de desarrollo tenemos que asegurar que todo el mundo usa las mismas versiones de todas las aplicaciones y librer\u00edas necesarios. Esto es m\u00e1s complicado de lo que parece, porque hay desarrolladores que prefieron una distribuci\u00f3n concreta, o incluso sistemas privativos. Incluso los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n suelen ser distintos. Los sistemas de producci\u00f3n suelen ser m\u00e1s nuevos y potentes y los antiguos se dejan para pruebas y pre-producci\u00f3n. Otro problema es que un mismo desarrollador o un mismo sistema de despliegue tenga que trabajar en m\u00e1s de un proyecto que requiera versiones distintas de librer\u00edas, complic\u00e1ndolo a\u00fan m\u00e1s. Docker viene a solucionar todos estos problemas, tanto para los desarrolladores como para los administradores de sistemas. Con Docker podemos crear entornos aislados con configuraciones que ser\u00e1n exactamente igual siempre.","title":"\u00bfA quien le interesa esto?"},{"location":"Sesion-1/Introducci%C3%B3n/#conceptos-basicos","text":"Antes de comenzar a instalar y usar docker es importante tener una serie de conceptos claros: Demonio de docker (docker daemon) : Es el proceso principal de docker. Escucha peticiones a la API y maneja los objetos de docker: im\u00e1genes, contenedores, redes, vol\u00famenes. Tambi\u00e9n es capaz de comunicarse con otros demonios para controlar servicios docker. Cliente de docker (docker client) : Es la principal herramienta que usan los administradores de sistema para interaccionar con el sistema Docker. Registro de docker (docker registry) : Es el lugar donde se almacenan las im\u00e1genes de Docker y poder descargarlas para reutilizarlas. Docker Hub es el principal registro p\u00fablico de Docker y contiene ya un mont\u00f3n de im\u00e1genes listas para ser usadas de multitud de servicios (mysql, wordpress, etc).","title":"Conceptos b\u00e1sicos"},{"location":"Sesion-2/Herramientas/","text":"Herramientas \u00b6 Kubernetes fue dise\u00f1ada como una plataforma: para poder construir un ecosistema de componentes y herramientas que hacen m\u00e1s f\u00e1cil el desplegar, escalar y administrar aplicaciones. Este ecosistema ofrece muchas funcionalidades entre las cuales destacan: Kubectl \u00b6 Usando kubectl, puedes inspeccionar recursos del cl\u00faster; crear, eliminar y actualizar componentes; Para m\u00e1s informaci\u00f3n: https://kubernetes.io/kubectl/ Kind \u00b6 Kind le permite usar Kubernetes en su m\u00e1quina local. Para m\u00e1s informaci\u00f3n: https://kubernetes.io/kind/ MiniKube \u00b6 Minikube es una herramienta que le permite usar Kubernetes en su m\u00e1quina local. minikube le permite ejecutar un \u00fanico nodo en su computadora personal para que pueda probar Kubernetes Para m\u00e1s informaci\u00f3n: https://kubernetes.io/minikube/ Kubeadm \u00b6 Tambi\u00e9n se puede utilizar kubeadm para crear y gestionar cl\u00fasteres de Kubernetes Para m\u00e1s informaci\u00f3n: https://kubernetes.io/kubeadm/","title":"Herramientas"},{"location":"Sesion-2/Herramientas/#herramientas","text":"Kubernetes fue dise\u00f1ada como una plataforma: para poder construir un ecosistema de componentes y herramientas que hacen m\u00e1s f\u00e1cil el desplegar, escalar y administrar aplicaciones. Este ecosistema ofrece muchas funcionalidades entre las cuales destacan:","title":"Herramientas"},{"location":"Sesion-2/Herramientas/#kubectl","text":"Usando kubectl, puedes inspeccionar recursos del cl\u00faster; crear, eliminar y actualizar componentes; Para m\u00e1s informaci\u00f3n: https://kubernetes.io/kubectl/","title":"Kubectl"},{"location":"Sesion-2/Herramientas/#kind","text":"Kind le permite usar Kubernetes en su m\u00e1quina local. Para m\u00e1s informaci\u00f3n: https://kubernetes.io/kind/","title":"Kind"},{"location":"Sesion-2/Herramientas/#minikube","text":"Minikube es una herramienta que le permite usar Kubernetes en su m\u00e1quina local. minikube le permite ejecutar un \u00fanico nodo en su computadora personal para que pueda probar Kubernetes Para m\u00e1s informaci\u00f3n: https://kubernetes.io/minikube/","title":"MiniKube"},{"location":"Sesion-2/Herramientas/#kubeadm","text":"Tambi\u00e9n se puede utilizar kubeadm para crear y gestionar cl\u00fasteres de Kubernetes Para m\u00e1s informaci\u00f3n: https://kubernetes.io/kubeadm/","title":"Kubeadm"},{"location":"Sesion-2/Introducci%C3%B3n/","text":"\u00bfQu\u00e9 es Kubernetes? \u00b6 Introducci\u00f3n \u00b6 Kubernetes v1.0 fue liberada el 21 de julio de 2015. Fue originalmente dise\u00f1ado por Google y donado a la Cloud Native Computing Foundation (parte de la Linux Foundation). Se trata de un sistema de c\u00f3digo libre para la automatizaci\u00f3n del despliegue, ajuste de escala y manejo de aplicaciones en contenedores. Soporta diferentes entornos para la ejecuci\u00f3n de contenedores, incluido Docker el cual vimos en la sesi\u00f3n anterior. Actualmente se utiliza en multitud de proyectos y empresas entre las cuales destaca: Rancher Labs en su plataforma de mejoramiento de contenedores Rancher\u200b. Red Hat para su producto OpenShift\u200b CoreOS para su producto Tectonic IBM para su producto IBM Spectrum Conductor for Containers.","title":"\u00bfQu\u00e9 es Kubernetes?"},{"location":"Sesion-2/Introducci%C3%B3n/#que-es-kubernetes","text":"","title":"\u00bfQu\u00e9 es Kubernetes?"},{"location":"Sesion-2/Introducci%C3%B3n/#introduccion","text":"Kubernetes v1.0 fue liberada el 21 de julio de 2015. Fue originalmente dise\u00f1ado por Google y donado a la Cloud Native Computing Foundation (parte de la Linux Foundation). Se trata de un sistema de c\u00f3digo libre para la automatizaci\u00f3n del despliegue, ajuste de escala y manejo de aplicaciones en contenedores. Soporta diferentes entornos para la ejecuci\u00f3n de contenedores, incluido Docker el cual vimos en la sesi\u00f3n anterior. Actualmente se utiliza en multitud de proyectos y empresas entre las cuales destaca: Rancher Labs en su plataforma de mejoramiento de contenedores Rancher\u200b. Red Hat para su producto OpenShift\u200b CoreOS para su producto Tectonic IBM para su producto IBM Spectrum Conductor for Containers.","title":"Introducci\u00f3n"},{"location":"Sesion-2/MiniKube/","text":"Pr\u00e1ctica \u00b6 Ahora que ya conocemos el funcionamiento de kubernetes llega el momento de afianzar estos conocimientos realizando una peque\u00f1a pr\u00e1ctica. Para ello haremos uso de una de las herramientas mencionadas anteriormente: MiniKube. Esta nos permitir\u00e1 levantar un nodo en nuestra m\u00e1quina para que podamos empezar a trabajar con Kubernetes. Requisitos m\u00ednimos: Dual-Core CPU o superior 2GB de RAM 20 GB de espacio libre en disco Conexi\u00f3n a Internet Administrador de contenedores o m\u00e1quinas virtuales, como: Docker, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox o VMWare Si tu equipo no cuenta con los recursos suficientes para ejecutar MiniKube o no quieres instalarlo en tu ordenador personal, no te preocupes puedes seguir igualmente el tutorial desde la web de MiniKube donde dispones de todas las instrucciones paso a paso y adm\u00e1s cuentas con una consola virtual para realizar el tutorial. Enlace al tutorial: Hello Minikube .","title":"Pr\u00e1ctica"},{"location":"Sesion-2/MiniKube/#practica","text":"Ahora que ya conocemos el funcionamiento de kubernetes llega el momento de afianzar estos conocimientos realizando una peque\u00f1a pr\u00e1ctica. Para ello haremos uso de una de las herramientas mencionadas anteriormente: MiniKube. Esta nos permitir\u00e1 levantar un nodo en nuestra m\u00e1quina para que podamos empezar a trabajar con Kubernetes. Requisitos m\u00ednimos: Dual-Core CPU o superior 2GB de RAM 20 GB de espacio libre en disco Conexi\u00f3n a Internet Administrador de contenedores o m\u00e1quinas virtuales, como: Docker, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox o VMWare Si tu equipo no cuenta con los recursos suficientes para ejecutar MiniKube o no quieres instalarlo en tu ordenador personal, no te preocupes puedes seguir igualmente el tutorial desde la web de MiniKube donde dispones de todas las instrucciones paso a paso y adm\u00e1s cuentas con una consola virtual para realizar el tutorial. Enlace al tutorial: Hello Minikube .","title":"Pr\u00e1ctica"}]}